#include <cstddef>
#include <cmath>
#include <pybind11/numpy.h>
namespace py = pybind11;

// Define a simple matrix multiplication function that attempts to mimic NumPy's behavior
py::array_t<float> kernel(py::array_t<float> a, py::array_t<float> b) {
    auto buf_a = a.request();
    auto buf_b = b.request();
    
    if (buf_a.ndim != 1 || buf_b.ndim != 1) {
        throw std::runtime_error("Number of dimensions must be 1");
    }
    
    size_t N = buf_a.shape[0];
    size_t K = buf_b.shape[0];
    
    // Create the result array with the correct shape
    py::array_t<float> result = py::array_t<float>({N});
    auto buf_result = result.request();
    
    float* ptr_a = static_cast<float*>(buf_a.ptr);
    float* ptr_b = static_cast<float*>(buf_b.ptr);
    float* ptr_result = static_cast<float*>(buf_result.ptr);
    
    // Initialize the result array to zeros
    for (size_t i = 0; i < N; ++i) {
        ptr_result[i] = 0.0f;
    }
    
    // Use cache-friendly iteration order and accumulate in blocks
    for (size_t i = 0; i < N; ++i) {
        for (size_t j = 0; j < K; ++j) {
            ptr_result[i] += ptr_a[i] * ptr_b[j];
        }
    }
    
    return result;
}